{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport useWindowDimensions from \"react-native-web/dist/exports/useWindowDimensions\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated, { runOnJS, runOnUI, useAnimatedReaction, useAnimatedScrollHandler, useAnimatedStyle, useDerivedValue, useSharedValue, withDelay, withTiming } from 'react-native-reanimated';\nimport { Context, TabNameContext } from \"./Context\";\nimport { Lazy } from \"./Lazy\";\nimport { MaterialTabBar, TABBAR_HEIGHT } from \"./MaterialTabBar\";\nimport { Tab } from \"./Tab\";\nimport { AnimatedFlatList, IS_IOS, makeRenderFunction, ONE_FRAME_MS, scrollToImpl } from \"./helpers\";\nimport { useAnimatedDynamicRefs, useContainerRef, useTabProps } from \"./hooks\";\nexport var Container = React.memo(React.forwardRef(function (_ref, ref) {\n  var initialTabName = _ref.initialTabName,\n      initialHeaderHeight = _ref.headerHeight,\n      _ref$minHeaderHeight = _ref.minHeaderHeight,\n      minHeaderHeight = _ref$minHeaderHeight === void 0 ? 0 : _ref$minHeaderHeight,\n      _ref$tabBarHeight = _ref.tabBarHeight,\n      initialTabBarHeight = _ref$tabBarHeight === void 0 ? TABBAR_HEIGHT : _ref$tabBarHeight,\n      _ref$revealHeaderOnSc = _ref.revealHeaderOnScroll,\n      revealHeaderOnScroll = _ref$revealHeaderOnSc === void 0 ? false : _ref$revealHeaderOnSc,\n      snapThreshold = _ref.snapThreshold,\n      children = _ref.children,\n      HeaderComponent = _ref.HeaderComponent,\n      _ref$TabBarComponent = _ref.TabBarComponent,\n      TabBarComponent = _ref$TabBarComponent === void 0 ? MaterialTabBar : _ref$TabBarComponent,\n      _ref$renderHeader = _ref.renderHeader,\n      renderHeader = _ref$renderHeader === void 0 ? makeRenderFunction(HeaderComponent) : _ref$renderHeader,\n      _ref$renderTabBar = _ref.renderTabBar,\n      renderTabBar = _ref$renderTabBar === void 0 ? makeRenderFunction(TabBarComponent) : _ref$renderTabBar,\n      headerContainerStyle = _ref.headerContainerStyle,\n      cancelTranslation = _ref.cancelTranslation,\n      containerStyle = _ref.containerStyle,\n      lazy = _ref.lazy,\n      cancelLazyFadeIn = _ref.cancelLazyFadeIn,\n      pagerProps = _ref.pagerProps,\n      onIndexChange = _ref.onIndexChange,\n      onTabChange = _ref.onTabChange;\n  var containerRef = useContainerRef();\n\n  var _useTabProps = useTabProps(children, Tab),\n      _useTabProps2 = _slicedToArray(_useTabProps, 2),\n      tabProps = _useTabProps2[0],\n      tabNamesArray = _useTabProps2[1];\n\n  var _useAnimatedDynamicRe = useAnimatedDynamicRefs(),\n      _useAnimatedDynamicRe2 = _slicedToArray(_useAnimatedDynamicRe, 2),\n      refMap = _useAnimatedDynamicRe2[0],\n      setRef = _useAnimatedDynamicRe2[1];\n\n  var windowWidth = useWindowDimensions().width;\n  var firstRender = React.useRef(true);\n\n  var _React$useState = React.useState(undefined),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      containerHeight = _React$useState2[0],\n      setContainerHeight = _React$useState2[1];\n\n  var _React$useState3 = React.useState(initialTabBarHeight),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      tabBarHeight = _React$useState4[0],\n      setTabBarHeight = _React$useState4[1];\n\n  var _React$useState5 = React.useState(!renderHeader ? 0 : initialHeaderHeight),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      headerHeight = _React$useState6[0],\n      setHeaderHeight = _React$useState6[1];\n\n  var contentInset = React.useMemo(function () {\n    return IS_IOS ? (headerHeight || 0) + (tabBarHeight || 0) : 0;\n  }, [headerHeight, tabBarHeight]);\n  var isSwiping = useSharedValue(false);\n  var isSnapping = useSharedValue(false);\n  var snappingTo = useSharedValue(0);\n  var isGliding = useSharedValue(false);\n  var offset = useSharedValue(0);\n  var accScrollY = useSharedValue(0);\n  var oldAccScrollY = useSharedValue(0);\n  var accDiffClamp = useSharedValue(0);\n  var isScrolling = useSharedValue(0);\n  var scrollYCurrent = useSharedValue(0);\n  var scrollY = useSharedValue(tabNamesArray.map(function () {\n    return 0;\n  }), false);\n  var contentHeights = useSharedValue(tabNamesArray.map(function () {\n    return 0;\n  }), false);\n  var tabNames = useDerivedValue(function () {\n    return tabNamesArray;\n  }, [tabNamesArray]);\n  var index = useSharedValue(initialTabName ? tabNames.value.findIndex(function (n) {\n    return n === initialTabName;\n  }) : 0);\n  var scrollX = useSharedValue(index.value * windowWidth, false);\n  var pagerOpacity = useSharedValue(initialHeaderHeight === undefined || index.value !== 0 ? 0 : 1, false);\n\n  var _React$useState7 = React.useState(tabNamesArray),\n      _React$useState8 = _slicedToArray(_React$useState7, 2),\n      data = _React$useState8[0],\n      setData = _React$useState8[1];\n\n  React.useEffect(function () {\n    setData(tabNamesArray);\n  }, [tabNamesArray]);\n  var focusedTab = useDerivedValue(function () {\n    return tabNames.value[index.value];\n  }, [tabNames]);\n  var calculateNextOffset = useSharedValue(index.value);\n  var headerScrollDistance = useDerivedValue(function () {\n    return headerHeight !== undefined ? headerHeight - minHeaderHeight : 0;\n  }, [headerHeight, minHeaderHeight]);\n  var getItemLayout = React.useCallback(function (_, index) {\n    return {\n      length: windowWidth,\n      offset: windowWidth * index,\n      index: index\n    };\n  }, [windowWidth]);\n  var indexDecimal = useDerivedValue(function () {\n    return scrollX.value / windowWidth;\n  }, [windowWidth]);\n  React.useEffect(function () {\n    if (!firstRender.current) {\n      var _containerRef$current;\n\n      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.scrollToIndex({\n        index: index.value,\n        animated: false\n      });\n    }\n  }, [windowWidth]);\n  var afterRender = useSharedValue(0);\n  React.useEffect(function () {\n    if (!firstRender.current) pagerOpacity.value = 0;\n    afterRender.value = withDelay(ONE_FRAME_MS * 5, withTiming(1, {\n      duration: 0\n    }));\n  }, [afterRender, pagerOpacity, tabNamesArray]);\n  React.useEffect(function () {\n    if (firstRender.current) {\n      if (initialTabName !== undefined && index.value !== 0) {\n        var _containerRef$current2;\n\n        (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.scrollToIndex({\n          index: index.value,\n          animated: false\n        });\n      }\n\n      firstRender.current = false;\n    }\n  }, [containerRef, initialTabName, windowWidth]);\n  useAnimatedReaction(function () {\n    return afterRender.value === 1;\n  }, function (trigger) {\n    if (trigger) {\n      afterRender.value = 0;\n      tabNamesArray.forEach(function (name) {\n        'worklet';\n\n        scrollToImpl(refMap[name], 0, scrollY.value[index.value] - contentInset, false);\n      });\n      pagerOpacity.value = withTiming(1);\n    }\n  }, [tabNamesArray, refMap, afterRender, contentInset]);\n  useAnimatedReaction(function () {\n    var nextIndex = isSwiping.value ? Math.round(indexDecimal.value) : null;\n    return nextIndex;\n  }, function (nextIndex) {\n    if (nextIndex !== null && nextIndex !== index.value) {\n      calculateNextOffset.value = nextIndex;\n    }\n  }, []);\n  var propagateTabChange = React.useCallback(function (change) {\n    onTabChange === null || onTabChange === void 0 ? void 0 : onTabChange(change);\n    onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(change.index);\n  }, [onIndexChange, onTabChange]);\n  useAnimatedReaction(function () {\n    return calculateNextOffset.value;\n  }, function (i) {\n    if (i !== index.value) {\n      offset.value = scrollY.value[index.value] - scrollY.value[i] + offset.value;\n      runOnJS(propagateTabChange)({\n        prevIndex: index.value,\n        index: i,\n        prevTabName: tabNames.value[index.value],\n        tabName: tabNames.value[i]\n      });\n      index.value = i;\n    }\n  }, []);\n  var scrollHandlerX = useAnimatedScrollHandler({\n    onScroll: function onScroll(event) {\n      var x = event.contentOffset.x;\n      scrollX.value = x;\n    },\n    onBeginDrag: function onBeginDrag() {\n      isSwiping.value = true;\n    },\n    onMomentumEnd: function onMomentumEnd() {\n      isSwiping.value = false;\n    }\n  }, []);\n  var renderItem = React.useCallback(function (_ref2) {\n    var i = _ref2.index;\n    if (!tabNames.value[i]) return null;\n    return React.createElement(TabNameContext.Provider, {\n      value: tabNames.value[i]\n    }, lazy ? React.createElement(Lazy, {\n      startMounted: i === index.value,\n      cancelLazyFadeIn: cancelLazyFadeIn\n    }, React.Children.toArray(children)[i]) : React.Children.toArray(children)[i]);\n  }, [children, lazy, tabNames.value, cancelLazyFadeIn]);\n  var headerTranslateY = useDerivedValue(function () {\n    return revealHeaderOnScroll ? -accDiffClamp.value : -Math.min(scrollYCurrent.value, headerScrollDistance.value);\n  }, [revealHeaderOnScroll]);\n  var stylez = useAnimatedStyle(function () {\n    return {\n      transform: [{\n        translateY: headerTranslateY.value\n      }]\n    };\n  }, [revealHeaderOnScroll]);\n  var getHeaderHeight = React.useCallback(function (event) {\n    var height = event.nativeEvent.layout.height;\n\n    if (headerHeight !== height) {\n      setHeaderHeight(height);\n    }\n  }, [headerHeight]);\n  var getTabBarHeight = React.useCallback(function (event) {\n    var height = event.nativeEvent.layout.height;\n    if (tabBarHeight !== height) setTabBarHeight(height);\n  }, [tabBarHeight]);\n  var onLayout = React.useCallback(function (event) {\n    var height = event.nativeEvent.layout.height;\n    if (containerHeight !== height) setContainerHeight(height);\n  }, [containerHeight]);\n  useAnimatedReaction(function () {\n    return (initialHeaderHeight === undefined || initialTabName !== undefined) && headerHeight !== undefined && pagerOpacity.value === 0;\n  }, function (update) {\n    if (update) {\n      pagerOpacity.value = withTiming(1);\n    }\n  }, [headerHeight]);\n  var pagerStylez = useAnimatedStyle(function () {\n    return {\n      opacity: pagerOpacity.value\n    };\n  }, []);\n  var onTabPress = React.useCallback(function (name) {\n    if (!isScrolling.value && !isGliding.value) {\n      var i = tabNames.value.findIndex(function (n) {\n        return n === name;\n      });\n      calculateNextOffset.value = i;\n\n      if (name === focusedTab.value) {\n        var _ref3 = refMap[name];\n        runOnUI(scrollToImpl)(_ref3, 0, headerScrollDistance.value - contentInset, true);\n      } else {\n        var _containerRef$current3;\n\n        (_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.scrollToIndex({\n          animated: true,\n          index: i\n        });\n      }\n    }\n  }, [containerRef, refMap, contentInset]);\n  React.useEffect(function () {\n    if (index.value >= tabNamesArray.length) {\n      onTabPress(tabNamesArray[tabNamesArray.length - 1]);\n    }\n  }, [index.value, onTabPress, tabNamesArray]);\n  var keyExtractor = React.useCallback(function (name) {\n    return name;\n  }, []);\n  React.useImperativeHandle(ref, function () {\n    return {\n      setIndex: function setIndex(index) {\n        if (isScrolling.value || isGliding.value) return false;\n        var name = tabNames.value[index];\n        onTabPress(name);\n        return true;\n      },\n      jumpToTab: function jumpToTab(name) {\n        if (isScrolling.value || isGliding.value) return false;\n        onTabPress(name);\n        return true;\n      },\n      getFocusedTab: function getFocusedTab() {\n        return tabNames.value[index.value];\n      },\n      getCurrentIndex: function getCurrentIndex() {\n        return index.value;\n      }\n    };\n  }, [onTabPress]);\n  return React.createElement(Context.Provider, {\n    value: {\n      contentInset: contentInset,\n      tabBarHeight: tabBarHeight || 0,\n      headerHeight: headerHeight || 0,\n      refMap: refMap,\n      tabNames: tabNames,\n      index: index,\n      snapThreshold: snapThreshold,\n      revealHeaderOnScroll: revealHeaderOnScroll,\n      focusedTab: focusedTab,\n      accDiffClamp: accDiffClamp,\n      indexDecimal: indexDecimal,\n      containerHeight: containerHeight,\n      scrollYCurrent: scrollYCurrent,\n      scrollY: scrollY,\n      setRef: setRef,\n      headerScrollDistance: headerScrollDistance,\n      accScrollY: accScrollY,\n      oldAccScrollY: oldAccScrollY,\n      offset: offset,\n      isScrolling: isScrolling,\n      scrollX: scrollX,\n      isGliding: isGliding,\n      isSnapping: isSnapping,\n      snappingTo: snappingTo,\n      contentHeights: contentHeights,\n      headerTranslateY: headerTranslateY\n    }\n  }, React.createElement(Animated.View, {\n    style: [styles.container, containerStyle],\n    onLayout: onLayout,\n    pointerEvents: \"box-none\"\n  }, React.createElement(Animated.View, {\n    pointerEvents: \"box-none\",\n    style: [styles.topContainer, headerContainerStyle, !cancelTranslation && stylez]\n  }, React.createElement(View, {\n    style: [styles.container, styles.headerContainer],\n    onLayout: getHeaderHeight,\n    pointerEvents: \"box-none\"\n  }, renderHeader && renderHeader({\n    containerRef: containerRef,\n    index: index,\n    tabNames: tabNamesArray,\n    focusedTab: focusedTab,\n    indexDecimal: indexDecimal,\n    onTabPress: onTabPress,\n    tabProps: tabProps\n  })), React.createElement(View, {\n    style: [styles.container, styles.tabBarContainer],\n    onLayout: getTabBarHeight,\n    pointerEvents: \"box-none\"\n  }, renderTabBar && renderTabBar({\n    containerRef: containerRef,\n    index: index,\n    tabNames: tabNamesArray,\n    focusedTab: focusedTab,\n    indexDecimal: indexDecimal,\n    onTabPress: onTabPress,\n    tabProps: tabProps\n  }))), headerHeight !== undefined && React.createElement(AnimatedFlatList, _extends({\n    ref: containerRef,\n    initialScrollIndex: index.value,\n    data: data,\n    keyExtractor: keyExtractor,\n    renderItem: renderItem,\n    horizontal: true,\n    pagingEnabled: true,\n    onScroll: scrollHandlerX,\n    showsHorizontalScrollIndicator: false,\n    getItemLayout: getItemLayout,\n    scrollEventThrottle: 16,\n    bounces: false\n  }, pagerProps, {\n    style: [pagerStylez, pagerProps === null || pagerProps === void 0 ? void 0 : pagerProps.style]\n  }))));\n}));\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  topContainer: {\n    position: 'absolute',\n    zIndex: 100,\n    width: '100%',\n    backgroundColor: 'white',\n    shadowColor: '#000000',\n    shadowOffset: {\n      width: 0,\n      height: 2\n    },\n    shadowOpacity: 0.23,\n    shadowRadius: 2.62,\n    elevation: 4\n  },\n  tabBarContainer: {\n    zIndex: 1\n  },\n  headerContainer: {\n    zIndex: 2\n  }\n});","map":{"version":3,"sources":["Container.tsx"],"names":["Container","headerHeight","minHeaderHeight","tabBarHeight","initialTabBarHeight","revealHeaderOnScroll","TabBarComponent","renderHeader","makeRenderFunction","renderTabBar","onTabChange","containerRef","useContainerRef","useTabProps","useAnimatedDynamicRefs","windowWidth","useWindowDimensions","firstRender","React","contentInset","IS_IOS","isSwiping","useSharedValue","isSnapping","snappingTo","isGliding","offset","accScrollY","oldAccScrollY","accDiffClamp","isScrolling","scrollYCurrent","scrollY","tabNamesArray","contentHeights","tabNames","useDerivedValue","index","initialTabName","n","scrollX","pagerOpacity","initialHeaderHeight","setData","focusedTab","calculateNextOffset","headerScrollDistance","getItemLayout","length","indexDecimal","animated","afterRender","withDelay","ONE_FRAME_MS","withTiming","duration","useAnimatedReaction","trigger","name","scrollToImpl","refMap","nextIndex","Math","propagateTabChange","change","onIndexChange","i","runOnJS","prevIndex","prevTabName","tabName","scrollHandlerX","useAnimatedScrollHandler","onScroll","event","x","onBeginDrag","onMomentumEnd","renderItem","lazy","cancelLazyFadeIn","headerTranslateY","stylez","useAnimatedStyle","transform","translateY","value","getHeaderHeight","height","setHeaderHeight","getTabBarHeight","setTabBarHeight","onLayout","containerHeight","setContainerHeight","update","pagerStylez","opacity","onTabPress","ref","runOnUI","keyExtractor","setIndex","jumpToTab","getFocusedTab","getCurrentIndex","snapThreshold","setRef","styles","tabProps","pagerProps","container","flex","topContainer","position","zIndex","width","backgroundColor","shadowColor","shadowOffset","shadowOpacity","shadowRadius","elevation","tabBarContainer","headerContainer"],"mappings":"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","sourcesContent":["import React from 'react'\nimport {\n  LayoutChangeEvent,\n  StyleSheet,\n  useWindowDimensions,\n  View,\n} from 'react-native'\nimport Animated, {\n  runOnJS,\n  runOnUI,\n  useAnimatedReaction,\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n  useDerivedValue,\n  useSharedValue,\n  withDelay,\n  withTiming,\n} from 'react-native-reanimated'\n\nimport { Context, TabNameContext } from './Context'\nimport { Lazy } from './Lazy'\nimport { MaterialTabBar, TABBAR_HEIGHT } from './MaterialTabBar'\nimport { Tab } from './Tab'\nimport {\n  AnimatedFlatList,\n  IS_IOS,\n  makeRenderFunction,\n  ONE_FRAME_MS,\n  scrollToImpl,\n} from './helpers'\nimport { useAnimatedDynamicRefs, useContainerRef, useTabProps } from './hooks'\nimport {\n  CollapsibleProps,\n  CollapsibleRef,\n  ContextType,\n  IndexChangeEventData,\n  TabName,\n} from './types'\n\n/**\n * Basic usage looks like this:\n *\n * ```tsx\n * import { Tabs } from 'react-native-collapsible-tab-view'\n *\n * const Example = () => {\n *   return (\n *     <Tabs.Container renderHeader={MyHeader}>\n *       <Tabs.Tab name=\"A\">\n *         <ScreenA />\n *       </Tabs.Tab>\n *       <Tabs.Tab name=\"B\">\n *         <ScreenB />\n *       </Tabs.Tab>\n *     </Tabs.Container>\n *   )\n * }\n * ```\n */\nexport const Container = React.memo(\n  React.forwardRef<CollapsibleRef, CollapsibleProps>(\n    (\n      {\n        initialTabName,\n        headerHeight: initialHeaderHeight,\n        minHeaderHeight = 0,\n        tabBarHeight: initialTabBarHeight = TABBAR_HEIGHT,\n        revealHeaderOnScroll = false,\n        snapThreshold,\n        children,\n        // TODO: these two are obsolete, remove them in v5.0\n        HeaderComponent,\n        TabBarComponent = MaterialTabBar,\n        renderHeader = makeRenderFunction(HeaderComponent),\n        renderTabBar = makeRenderFunction(TabBarComponent),\n        headerContainerStyle,\n        cancelTranslation,\n        containerStyle,\n        lazy,\n        cancelLazyFadeIn,\n        pagerProps,\n        onIndexChange,\n        onTabChange,\n      },\n      ref\n    ) => {\n      const containerRef = useContainerRef()\n\n      const [tabProps, tabNamesArray] = useTabProps(children, Tab)\n\n      const [refMap, setRef] = useAnimatedDynamicRefs()\n\n      const windowWidth = useWindowDimensions().width\n      const firstRender = React.useRef(true)\n\n      const [containerHeight, setContainerHeight] = React.useState<\n        number | undefined\n      >(undefined)\n      const [tabBarHeight, setTabBarHeight] = React.useState<\n        number | undefined\n      >(initialTabBarHeight)\n      const [headerHeight, setHeaderHeight] = React.useState<\n        number | undefined\n      >(!renderHeader ? 0 : initialHeaderHeight)\n\n      const contentInset = React.useMemo(\n        () => (IS_IOS ? (headerHeight || 0) + (tabBarHeight || 0) : 0),\n        [headerHeight, tabBarHeight]\n      )\n\n      const isSwiping = useSharedValue(false)\n      const isSnapping: ContextType['isSnapping'] = useSharedValue(false)\n      const snappingTo: ContextType['snappingTo'] = useSharedValue(0)\n      const isGliding: ContextType['isGliding'] = useSharedValue(false)\n      const offset: ContextType['offset'] = useSharedValue(0)\n      const accScrollY: ContextType['accScrollY'] = useSharedValue(0)\n      const oldAccScrollY: ContextType['oldAccScrollY'] = useSharedValue(0)\n      const accDiffClamp: ContextType['accDiffClamp'] = useSharedValue(0)\n      const isScrolling: ContextType['isScrolling'] = useSharedValue(0)\n      const scrollYCurrent: ContextType['scrollYCurrent'] = useSharedValue(0)\n      const scrollY: ContextType['scrollY'] = useSharedValue(\n        tabNamesArray.map(() => 0),\n        false\n      )\n\n      const contentHeights: ContextType['contentHeights'] = useSharedValue(\n        tabNamesArray.map(() => 0),\n        false\n      )\n\n      const tabNames: ContextType['tabNames'] = useDerivedValue<TabName[]>(\n        () => tabNamesArray,\n        [tabNamesArray]\n      )\n      const index: ContextType['index'] = useSharedValue(\n        initialTabName\n          ? tabNames.value.findIndex((n) => n === initialTabName)\n          : 0\n      )\n      const scrollX: ContextType['scrollX'] = useSharedValue(\n        index.value * windowWidth,\n        false\n      )\n      const pagerOpacity = useSharedValue(\n        initialHeaderHeight === undefined || index.value !== 0 ? 0 : 1,\n        false\n      )\n      const [data, setData] = React.useState(tabNamesArray)\n\n      React.useEffect(() => {\n        setData(tabNamesArray)\n      }, [tabNamesArray])\n\n      const focusedTab: ContextType['focusedTab'] = useDerivedValue<TabName>(() => {\n        return tabNames.value[index.value]\n      }, [tabNames])\n      const calculateNextOffset = useSharedValue(index.value)\n      const headerScrollDistance: ContextType['headerScrollDistance'] = useDerivedValue(() => {\n        return headerHeight !== undefined ? headerHeight - minHeaderHeight : 0\n      }, [headerHeight, minHeaderHeight])\n\n      const getItemLayout = React.useCallback(\n        (_: unknown, index: number) => ({\n          length: windowWidth,\n          offset: windowWidth * index,\n          index,\n        }),\n        [windowWidth]\n      )\n\n      const indexDecimal: ContextType['indexDecimal'] = useDerivedValue(() => {\n        return scrollX.value / windowWidth\n      }, [windowWidth])\n\n      // handle window resize\n      React.useEffect(() => {\n        if (!firstRender.current) {\n          containerRef.current?.scrollToIndex({\n            index: index.value,\n            animated: false,\n          })\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, [windowWidth])\n\n      const afterRender = useSharedValue(0)\n      React.useEffect(() => {\n        if (!firstRender.current) pagerOpacity.value = 0\n        afterRender.value = withDelay(\n          ONE_FRAME_MS * 5,\n          withTiming(1, { duration: 0 })\n        )\n      }, [afterRender, pagerOpacity, tabNamesArray])\n\n      React.useEffect(() => {\n        if (firstRender.current) {\n          if (initialTabName !== undefined && index.value !== 0) {\n            containerRef.current?.scrollToIndex({\n              index: index.value,\n              animated: false,\n            })\n          }\n          firstRender.current = false\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, [containerRef, initialTabName, windowWidth])\n\n      // the purpose of this is to scroll to the proper position if dynamic tabs are changing\n      useAnimatedReaction(\n        () => {\n          return afterRender.value === 1\n        },\n        (trigger) => {\n          if (trigger) {\n            afterRender.value = 0\n            tabNamesArray.forEach((name) => {\n              'worklet'\n              scrollToImpl(\n                refMap[name],\n                0,\n                scrollY.value[index.value] - contentInset,\n                false\n              )\n            })\n\n            pagerOpacity.value = withTiming(1)\n          }\n        },\n        [tabNamesArray, refMap, afterRender, contentInset]\n      )\n\n      // derived from scrollX\n      // calculate the next offset and index if swiping\n      // if scrollX changes from tab press,\n      // the same logic must be done, but knowing\n      // the next index in advance\n      useAnimatedReaction(\n        () => {\n          const nextIndex = isSwiping.value\n            ? Math.round(indexDecimal.value)\n            : null\n          return nextIndex\n        },\n        (nextIndex) => {\n          if (nextIndex !== null && nextIndex !== index.value) {\n            calculateNextOffset.value = nextIndex\n          }\n        },\n        []\n      )\n\n      const propagateTabChange = React.useCallback(\n        (change: IndexChangeEventData<TabName>) => {\n          onTabChange?.(change)\n          onIndexChange?.(change.index)\n        },\n        [onIndexChange, onTabChange]\n      )\n\n      useAnimatedReaction(\n        () => {\n          return calculateNextOffset.value\n        },\n        (i) => {\n          if (i !== index.value) {\n            offset.value =\n              scrollY.value[index.value] - scrollY.value[i] + offset.value\n            runOnJS(propagateTabChange)({\n              prevIndex: index.value,\n              index: i,\n              prevTabName: tabNames.value[index.value],\n              tabName: tabNames.value[i],\n            })\n            index.value = i\n          }\n        },\n        []\n      )\n\n      const scrollHandlerX = useAnimatedScrollHandler(\n        {\n          onScroll: (event) => {\n            const { x } = event.contentOffset\n            scrollX.value = x\n          },\n          onBeginDrag: () => {\n            isSwiping.value = true\n          },\n          onMomentumEnd: () => {\n            isSwiping.value = false\n          },\n        },\n        []\n      )\n\n      const renderItem = React.useCallback(\n        ({ index: i }) => {\n          if (!tabNames.value[i]) return null\n          return (\n            <TabNameContext.Provider value={tabNames.value[i]}>\n              {lazy ? (\n                <Lazy\n                  startMounted={i === index.value}\n                  cancelLazyFadeIn={cancelLazyFadeIn}\n                >\n                  {React.Children.toArray(children)[i] as React.ReactElement}\n                </Lazy>\n              ) : (\n                React.Children.toArray(children)[i]\n              )}\n            </TabNameContext.Provider>\n          )\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [children, lazy, tabNames.value, cancelLazyFadeIn]\n      )\n\n      const headerTranslateY = useDerivedValue(() => {\n        return revealHeaderOnScroll\n          ? -accDiffClamp.value\n          : -Math.min(scrollYCurrent.value, headerScrollDistance.value)\n      }, [revealHeaderOnScroll])\n\n      const stylez = useAnimatedStyle(() => {\n        return {\n          transform: [\n            {\n              translateY: headerTranslateY.value,\n            },\n          ],\n        }\n      }, [revealHeaderOnScroll])\n\n      const getHeaderHeight = React.useCallback(\n        (event: LayoutChangeEvent) => {\n          const height = event.nativeEvent.layout.height\n          if (headerHeight !== height) {\n            setHeaderHeight(height)\n          }\n        },\n        [headerHeight]\n      )\n\n      const getTabBarHeight = React.useCallback(\n        (event: LayoutChangeEvent) => {\n          const height = event.nativeEvent.layout.height\n          if (tabBarHeight !== height) setTabBarHeight(height)\n        },\n        [tabBarHeight]\n      )\n\n      const onLayout = React.useCallback(\n        (event: LayoutChangeEvent) => {\n          const height = event.nativeEvent.layout.height\n          if (containerHeight !== height) setContainerHeight(height)\n        },\n        [containerHeight]\n      )\n\n      // fade in the pager if the headerHeight is not defined\n      useAnimatedReaction(\n        () => {\n          return (\n            (initialHeaderHeight === undefined ||\n              initialTabName !== undefined) &&\n            headerHeight !== undefined &&\n            pagerOpacity.value === 0\n          )\n        },\n        (update) => {\n          if (update) {\n            pagerOpacity.value = withTiming(1)\n          }\n        },\n        [headerHeight]\n      )\n\n      const pagerStylez = useAnimatedStyle(() => {\n        return {\n          opacity: pagerOpacity.value,\n        }\n      }, [])\n\n      const onTabPress = React.useCallback(\n        (name: TabName) => {\n          // simplify logic by preventing index change\n          // when is scrolling or gliding.\n          if (!isScrolling.value && !isGliding.value) {\n            const i = tabNames.value.findIndex((n) => n === name)\n            calculateNextOffset.value = i\n            if (name === focusedTab.value) {\n              const ref = refMap[name]\n              runOnUI(scrollToImpl)(\n                ref,\n                0,\n                headerScrollDistance.value - contentInset,\n                true\n              )\n            } else {\n              containerRef.current?.scrollToIndex({ animated: true, index: i })\n            }\n          }\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [containerRef, refMap, contentInset]\n      )\n\n      React.useEffect(() => {\n        if (index.value >= tabNamesArray.length) {\n          onTabPress(tabNamesArray[tabNamesArray.length - 1])\n        }\n      }, [index.value, onTabPress, tabNamesArray])\n\n      const keyExtractor = React.useCallback((name) => name, [])\n\n      React.useImperativeHandle(\n        ref,\n        () => ({\n          setIndex: (index) => {\n            if (isScrolling.value || isGliding.value) return false\n            const name = tabNames.value[index]\n            onTabPress(name)\n            return true\n          },\n          jumpToTab: (name) => {\n            if (isScrolling.value || isGliding.value) return false\n            onTabPress(name)\n            return true\n          },\n          getFocusedTab: () => {\n            return tabNames.value[index.value]\n          },\n          getCurrentIndex: () => {\n            return index.value\n          },\n        }),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [onTabPress]\n      )\n\n      return (\n        <Context.Provider\n          value={{\n            contentInset,\n            tabBarHeight: tabBarHeight || 0,\n            headerHeight: headerHeight || 0,\n            refMap,\n            tabNames,\n            index,\n            snapThreshold,\n            revealHeaderOnScroll,\n            focusedTab,\n            accDiffClamp,\n            indexDecimal,\n            containerHeight,\n            scrollYCurrent,\n            scrollY,\n            setRef,\n            headerScrollDistance,\n            accScrollY,\n            oldAccScrollY,\n            offset,\n            isScrolling,\n            scrollX,\n            isGliding,\n            isSnapping,\n            snappingTo,\n            contentHeights,\n            headerTranslateY,\n          }}\n        >\n          <Animated.View\n            style={[styles.container, containerStyle]}\n            onLayout={onLayout}\n            pointerEvents=\"box-none\"\n          >\n            <Animated.View\n              pointerEvents=\"box-none\"\n              style={[\n                styles.topContainer,\n                headerContainerStyle,\n                !cancelTranslation && stylez,\n              ]}\n            >\n              <View\n                style={[styles.container, styles.headerContainer]}\n                onLayout={getHeaderHeight}\n                pointerEvents=\"box-none\"\n              >\n                {renderHeader &&\n                  renderHeader({\n                    containerRef,\n                    index,\n                    tabNames: tabNamesArray,\n                    focusedTab,\n                    indexDecimal,\n                    onTabPress,\n                    tabProps,\n                  })}\n              </View>\n              <View\n                style={[styles.container, styles.tabBarContainer]}\n                onLayout={getTabBarHeight}\n                pointerEvents=\"box-none\"\n              >\n                {renderTabBar &&\n                  renderTabBar({\n                    containerRef,\n                    index,\n                    tabNames: tabNamesArray,\n                    focusedTab,\n                    indexDecimal,\n                    onTabPress,\n                    tabProps,\n                  })}\n              </View>\n            </Animated.View>\n            {headerHeight !== undefined && (\n              <AnimatedFlatList\n                // @ts-expect-error problem with reanimated types, they're missing `ref`\n                ref={containerRef}\n                initialScrollIndex={index.value}\n                data={data}\n                keyExtractor={keyExtractor}\n                renderItem={renderItem}\n                horizontal\n                pagingEnabled\n                onScroll={scrollHandlerX}\n                showsHorizontalScrollIndicator={false}\n                getItemLayout={getItemLayout}\n                scrollEventThrottle={16}\n                bounces={false}\n                {...pagerProps}\n                style={[pagerStylez, pagerProps?.style]}\n              />\n            )}\n          </Animated.View>\n        </Context.Provider>\n      )\n    }\n  )\n)\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  topContainer: {\n    position: 'absolute',\n    zIndex: 100,\n    width: '100%',\n    backgroundColor: 'white',\n    shadowColor: '#000000',\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.23,\n    shadowRadius: 2.62,\n    elevation: 4,\n  },\n  tabBarContainer: {\n    zIndex: 1,\n  },\n  headerContainer: {\n    zIndex: 2,\n  },\n})\n"]},"metadata":{},"sourceType":"module"}