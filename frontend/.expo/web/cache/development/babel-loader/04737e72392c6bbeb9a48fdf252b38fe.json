{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _excluded = [\"name\", \"children\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useMemo, Children, useState, useCallback, useContext, useEffect } from 'react';\nimport useWindowDimensions from \"react-native-web/dist/exports/useWindowDimensions\";\nimport { cancelAnimation, useAnimatedReaction, useAnimatedRef, useAnimatedScrollHandler, useSharedValue, withDelay, withTiming, interpolate, Extrapolate, runOnJS, runOnUI, useDerivedValue } from 'react-native-reanimated';\nimport { useDeepCompareMemo } from 'use-deep-compare';\nimport { Context, TabNameContext } from \"./Context\";\nimport { IS_IOS, ONE_FRAME_MS, scrollToImpl } from \"./helpers\";\nexport function useContainerRef() {\n  return useAnimatedRef();\n}\nexport function useAnimatedDynamicRefs() {\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      map = _useState2[0],\n      setMap = _useState2[1];\n\n  var setRef = useCallback(function (key, ref) {\n    setMap(function (map) {\n      return _objectSpread(_objectSpread({}, map), {}, _defineProperty({}, key, ref));\n    });\n    return ref;\n  }, []);\n  return [map, setRef];\n}\nexport function useTabProps(children, tabType) {\n  var options = useMemo(function () {\n    var tabOptions = new Map();\n\n    if (children) {\n      Children.forEach(children, function (element, index) {\n        if (!element) return;\n        if (element.type !== tabType) throw new Error('Container children must be wrapped in a <Tabs.Tab ... /> component');\n\n        var _element$props = element.props,\n            name = _element$props.name,\n            children = _element$props.children,\n            options = _objectWithoutProperties(_element$props, _excluded);\n\n        if (tabOptions.has(name)) throw new Error(\"Tab names must be unique, \".concat(name, \" already exists\"));\n        tabOptions.set(name, _objectSpread({\n          index: index,\n          name: name\n        }, options));\n      });\n    }\n\n    return tabOptions;\n  }, [children, tabType]);\n  var optionEntries = Array.from(options.entries());\n  var optionKeys = Array.from(options.keys());\n  var memoizedOptions = useDeepCompareMemo(function () {\n    return options;\n  }, [optionEntries]);\n  var memoizedTabNames = useDeepCompareMemo(function () {\n    return optionKeys;\n  }, [optionKeys]);\n  return [memoizedOptions, memoizedTabNames];\n}\nexport function useTabsContext() {\n  var c = useContext(Context);\n  if (!c) throw new Error('useTabsContext must be inside a Tabs.Container');\n  return c;\n}\nexport function useTabNameContext() {\n  var c = useContext(TabNameContext);\n  if (!c) throw new Error('useTabNameContext must be inside a TabNameContext');\n  return c;\n}\nexport function useCollapsibleStyle() {\n  var _useTabsContext = useTabsContext(),\n      headerHeight = _useTabsContext.headerHeight,\n      tabBarHeight = _useTabsContext.tabBarHeight,\n      containerHeight = _useTabsContext.containerHeight;\n\n  var windowWidth = useWindowDimensions().width;\n  return {\n    style: {\n      width: windowWidth\n    },\n    contentContainerStyle: {\n      minHeight: IS_IOS ? (containerHeight || 0) - tabBarHeight : (containerHeight || 0) + headerHeight,\n      paddingTop: IS_IOS ? 0 : headerHeight + tabBarHeight\n    },\n    progressViewOffset: headerHeight + tabBarHeight\n  };\n}\nexport function useUpdateScrollViewContentSize(_ref) {\n  var name = _ref.name;\n\n  var _useTabsContext2 = useTabsContext(),\n      tabNames = _useTabsContext2.tabNames,\n      contentHeights = _useTabsContext2.contentHeights;\n\n  var setContentHeights = useCallback(function (name, height) {\n    var tabIndex = tabNames.value.indexOf(name);\n    contentHeights.value[tabIndex] = height;\n    contentHeights.value = _toConsumableArray(contentHeights.value);\n  }, [contentHeights, tabNames.value]);\n  var scrollContentSizeChange = useCallback(function (_, h) {\n    runOnUI(setContentHeights)(name, h);\n  }, [setContentHeights, name]);\n  return scrollContentSizeChange;\n}\nexport function useChainCallback() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  var callAll = useCallback(function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    fns.forEach(function (fn) {\n      if (typeof fn === 'function') {\n        fn.apply(void 0, args);\n      }\n    });\n  }, [fns]);\n  return callAll;\n}\nexport function useScroller() {\n  var _useTabsContext3 = useTabsContext(),\n      contentInset = _useTabsContext3.contentInset;\n\n  var scroller = useCallback(function (ref, x, y, animated, _debugKey) {\n    'worklet';\n\n    if (!ref) return;\n    scrollToImpl(ref, x, y - contentInset, animated);\n  }, [contentInset]);\n  return scroller;\n}\nexport var useScrollHandlerY = function useScrollHandlerY(name, _ref2) {\n  var enabled = _ref2.enabled;\n\n  var _useTabsContext4 = useTabsContext(),\n      accDiffClamp = _useTabsContext4.accDiffClamp,\n      focusedTab = _useTabsContext4.focusedTab,\n      snapThreshold = _useTabsContext4.snapThreshold,\n      revealHeaderOnScroll = _useTabsContext4.revealHeaderOnScroll,\n      refMap = _useTabsContext4.refMap,\n      tabNames = _useTabsContext4.tabNames,\n      index = _useTabsContext4.index,\n      headerHeight = _useTabsContext4.headerHeight,\n      contentInset = _useTabsContext4.contentInset,\n      containerHeight = _useTabsContext4.containerHeight,\n      scrollYCurrent = _useTabsContext4.scrollYCurrent,\n      scrollY = _useTabsContext4.scrollY,\n      isScrolling = _useTabsContext4.isScrolling,\n      isGliding = _useTabsContext4.isGliding,\n      oldAccScrollY = _useTabsContext4.oldAccScrollY,\n      accScrollY = _useTabsContext4.accScrollY,\n      offset = _useTabsContext4.offset,\n      headerScrollDistance = _useTabsContext4.headerScrollDistance,\n      isSnapping = _useTabsContext4.isSnapping,\n      snappingTo = _useTabsContext4.snappingTo,\n      contentHeights = _useTabsContext4.contentHeights;\n\n  var afterDrag = useSharedValue(0);\n  var tabIndex = useMemo(function () {\n    return tabNames.value.findIndex(function (n) {\n      return n === name;\n    });\n  }, [tabNames, name]);\n  var scrollTo = useScroller();\n\n  var onMomentumEnd = function onMomentumEnd() {\n    'worklet';\n\n    if (!enabled) return;\n\n    if (typeof snapThreshold === 'number') {\n      if (revealHeaderOnScroll) {\n        if (accDiffClamp.value > 0) {\n          if (scrollYCurrent.value > headerScrollDistance.value * snapThreshold) {\n            if (accDiffClamp.value <= headerScrollDistance.value * snapThreshold) {\n              isSnapping.value = true;\n              accDiffClamp.value = withTiming(0, undefined, function () {\n                isSnapping.value = false;\n              });\n            } else if (accDiffClamp.value < headerScrollDistance.value) {\n              isSnapping.value = true;\n              accDiffClamp.value = withTiming(headerScrollDistance.value, undefined, function () {\n                isSnapping.value = false;\n              });\n\n              if (scrollYCurrent.value < headerScrollDistance.value) {\n                scrollTo(refMap[name], 0, headerScrollDistance.value, true, \"[\".concat(name, \"] sticky snap up\"));\n              }\n            }\n          } else {\n            isSnapping.value = true;\n            accDiffClamp.value = withTiming(0, undefined, function () {\n              isSnapping.value = false;\n            });\n          }\n        }\n      } else {\n        if (scrollYCurrent.value <= headerScrollDistance.value * snapThreshold) {\n          snappingTo.value = 0;\n          scrollTo(refMap[name], 0, 0, true, \"[\".concat(name, \"] snap down\"));\n        } else if (scrollYCurrent.value <= headerScrollDistance.value) {\n          snappingTo.value = headerScrollDistance.value;\n          scrollTo(refMap[name], 0, headerScrollDistance.value, true, \"[\".concat(name, \"] snap up\"));\n        }\n\n        isSnapping.value = false;\n      }\n    }\n\n    isGliding.value = false;\n  };\n\n  var contentHeight = useDerivedValue(function () {\n    var tabIndex = tabNames.value.indexOf(name);\n    return contentHeights.value[tabIndex] || Number.MAX_VALUE;\n  }, []);\n  var scrollHandler = useAnimatedScrollHandler({\n    onScroll: function onScroll(event) {\n      if (!enabled) return;\n\n      if (focusedTab.value === name) {\n        if (IS_IOS) {\n          var y = event.contentOffset.y;\n          y = y + contentInset;\n          var clampMax = contentHeight.value - (containerHeight || 0) + contentInset;\n          scrollYCurrent.value = interpolate(y, [0, clampMax], [0, clampMax], Extrapolate.CLAMP);\n        } else {\n          var _y = event.contentOffset.y;\n          scrollYCurrent.value = _y;\n        }\n\n        scrollY.value[index.value] = scrollYCurrent.value;\n        oldAccScrollY.value = accScrollY.value;\n        accScrollY.value = scrollY.value[index.value] + offset.value;\n\n        if (!isSnapping.value && revealHeaderOnScroll) {\n          var delta = accScrollY.value - oldAccScrollY.value;\n          var nextValue = accDiffClamp.value + delta;\n\n          if (delta > 0) {\n            accDiffClamp.value = Math.min(headerScrollDistance.value, nextValue);\n          } else if (delta < 0) {\n            accDiffClamp.value = Math.max(0, nextValue);\n          }\n        }\n\n        isScrolling.value = 1;\n        cancelAnimation(isScrolling);\n        isScrolling.value = withDelay(ONE_FRAME_MS * 3, withTiming(0, {\n          duration: 0\n        }));\n      }\n    },\n    onBeginDrag: function onBeginDrag() {\n      if (!enabled) return;\n      cancelAnimation(accDiffClamp);\n      isSnapping.value = false;\n      isScrolling.value = 0;\n      isGliding.value = false;\n      if (IS_IOS) cancelAnimation(afterDrag);\n    },\n    onEndDrag: function onEndDrag() {\n      if (!enabled) return;\n      isGliding.value = true;\n\n      if (IS_IOS) {\n        afterDrag.value = withDelay(ONE_FRAME_MS, withTiming(0, {\n          duration: 0\n        }, function (isFinished) {\n          if (isFinished) {\n            isGliding.value = false;\n            onMomentumEnd();\n          }\n        }));\n      }\n    },\n    onMomentumBegin: function onMomentumBegin() {\n      if (!enabled) return;\n\n      if (IS_IOS) {\n        cancelAnimation(afterDrag);\n      }\n    },\n    onMomentumEnd: onMomentumEnd\n  }, [refMap, name, revealHeaderOnScroll, containerHeight, contentInset, snapThreshold, enabled, scrollTo]);\n  useAnimatedReaction(function () {\n    return !isSnapping.value && !isScrolling.value && !isGliding.value && enabled;\n  }, function (sync) {\n    if (sync && focusedTab.value !== name) {\n      var nextPosition = null;\n      var focusedScrollY = scrollY.value[index.value];\n      var tabScrollY = scrollY.value[tabIndex];\n      var areEqual = focusedScrollY === tabScrollY;\n\n      if (!areEqual) {\n        var currIsOnTop = tabScrollY <= headerScrollDistance.value + 1;\n        var focusedIsOnTop = focusedScrollY <= headerScrollDistance.value + 1;\n\n        if (revealHeaderOnScroll) {\n          var hasGap = accDiffClamp.value > tabScrollY;\n\n          if (hasGap || currIsOnTop) {\n            nextPosition = accDiffClamp.value;\n          }\n        } else if (typeof snapThreshold === 'number') {\n          if (focusedIsOnTop) {\n            nextPosition = snappingTo.value;\n          } else if (currIsOnTop) {\n            nextPosition = headerHeight;\n          }\n        } else if (currIsOnTop || focusedIsOnTop) {\n          nextPosition = Math.min(focusedScrollY, headerScrollDistance.value);\n        }\n      }\n\n      if (nextPosition !== null) {\n        scrollY.value[tabIndex] = nextPosition;\n        scrollTo(refMap[name], 0, nextPosition, false, \"[\".concat(name, \"] sync pane\"));\n      }\n    }\n  }, [revealHeaderOnScroll, refMap, snapThreshold, tabIndex, enabled, scrollTo]);\n  return scrollHandler;\n};\nexport function useSharedAnimatedRef(outerRef) {\n  var ref = useAnimatedRef();\n  useEffect(function () {\n    if (!outerRef) {\n      return;\n    }\n\n    if (typeof outerRef === 'function') {\n      outerRef(ref.current);\n    } else {\n      outerRef.current = ref.current;\n    }\n  });\n  return ref;\n}\nexport function useAfterMountEffect(effect) {\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      didExecute = _useState4[0],\n      setDidExecute = _useState4[1];\n\n  var result = useEffect(function () {\n    if (didExecute) return;\n    var timeout = setTimeout(function () {\n      effect();\n      setDidExecute(true);\n    }, 0);\n    return function () {\n      clearTimeout(timeout);\n    };\n  }, [didExecute, effect]);\n  return result;\n}\nexport function useConvertAnimatedToValue(animatedValue) {\n  var _useState5 = useState(animatedValue.value),\n      _useState6 = _slicedToArray(_useState5, 2),\n      value = _useState6[0],\n      setValue = _useState6[1];\n\n  useAnimatedReaction(function () {\n    return animatedValue.value;\n  }, function (animValue) {\n    if (animValue !== value) {\n      runOnJS(setValue)(animValue);\n    }\n  }, [value]);\n  return value;\n}\nexport function useHeaderMeasurements() {\n  var _useTabsContext5 = useTabsContext(),\n      headerTranslateY = _useTabsContext5.headerTranslateY,\n      headerHeight = _useTabsContext5.headerHeight;\n\n  return {\n    top: headerTranslateY,\n    height: headerHeight\n  };\n}\nexport function useFocusedTab() {\n  var _useTabsContext6 = useTabsContext(),\n      focusedTab = _useTabsContext6.focusedTab;\n\n  var focusedTabValue = useConvertAnimatedToValue(focusedTab);\n  return focusedTabValue;\n}\nexport function useAnimatedTabIndex() {\n  var _useTabsContext7 = useTabsContext(),\n      indexDecimal = _useTabsContext7.indexDecimal;\n\n  return indexDecimal;\n}","map":{"version":3,"sources":["hooks.tsx"],"names":["useAnimatedRef","useState","setRef","useCallback","setMap","map","ref","options","useMemo","tabOptions","Children","element","index","name","optionEntries","Array","optionKeys","memoizedOptions","useDeepCompareMemo","memoizedTabNames","c","useContext","containerHeight","useTabsContext","windowWidth","useWindowDimensions","style","width","contentContainerStyle","minHeight","IS_IOS","paddingTop","headerHeight","tabBarHeight","progressViewOffset","contentHeights","setContentHeights","tabIndex","tabNames","scrollContentSizeChange","runOnUI","callAll","fns","fn","contentInset","scroller","scrollToImpl","y","useScrollHandlerY","enabled","afterDrag","useSharedValue","n","scrollTo","useScroller","onMomentumEnd","accDiffClamp","scrollYCurrent","headerScrollDistance","isSnapping","withTiming","refMap","snappingTo","isGliding","contentHeight","useDerivedValue","Number","scrollHandler","useAnimatedScrollHandler","onScroll","event","focusedTab","clampMax","interpolate","Extrapolate","scrollY","oldAccScrollY","accScrollY","offset","delta","nextValue","Math","isScrolling","cancelAnimation","withDelay","ONE_FRAME_MS","duration","onBeginDrag","onEndDrag","isFinished","onMomentumBegin","useAnimatedReaction","sync","nextPosition","focusedScrollY","tabScrollY","areEqual","currIsOnTop","focusedIsOnTop","hasGap","useEffect","outerRef","result","timeout","setTimeout","effect","setDidExecute","clearTimeout","animatedValue","animValue","runOnJS","top","height","focusedTabValue","useConvertAnimatedToValue","indexDecimal"],"mappings":"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","sourcesContent":["import {\n  useMemo,\n  Children,\n  useState,\n  useCallback,\n  useContext,\n  MutableRefObject,\n  useEffect,\n} from 'react'\nimport { useWindowDimensions } from 'react-native'\nimport { ContainerRef, RefComponent } from 'react-native-collapsible-tab-view'\nimport Animated, {\n  cancelAnimation,\n  useAnimatedReaction,\n  useAnimatedRef,\n  useAnimatedScrollHandler,\n  useSharedValue,\n  withDelay,\n  withTiming,\n  interpolate,\n  Extrapolate,\n  runOnJS,\n  runOnUI,\n  useDerivedValue,\n} from 'react-native-reanimated'\nimport { useDeepCompareMemo } from 'use-deep-compare'\n\nimport { Context, TabNameContext } from './Context'\nimport { IS_IOS, ONE_FRAME_MS, scrollToImpl } from './helpers'\nimport {\n  CollapsibleStyle,\n  ContextType,\n  TabName,\n  TabReactElement,\n  TabsWithProps,\n  Ref,\n} from './types'\n\nexport function useContainerRef() {\n  return useAnimatedRef<ContainerRef>()\n}\n\nexport function useAnimatedDynamicRefs(): [\n  ContextType['refMap'],\n  ContextType['setRef']\n] {\n  const [map, setMap] = useState<ContextType['refMap']>({})\n  const setRef = useCallback(function <T extends RefComponent>(\n    key: TabName,\n    ref: React.RefObject<T>\n  ) {\n    setMap((map) => ({ ...map, [key]: ref }))\n    return ref\n  },\n  [])\n\n  return [map, setRef]\n}\n\nexport function useTabProps<T extends TabName>(\n  children: TabReactElement<T>[] | TabReactElement<T>,\n  tabType: Function\n): [TabsWithProps<T>, T[]] {\n  const options = useMemo(() => {\n    const tabOptions: TabsWithProps<T> = new Map()\n    if (children) {\n      Children.forEach(children, (element, index) => {\n        if (!element) return\n\n        if (element.type !== tabType)\n          throw new Error(\n            'Container children must be wrapped in a <Tabs.Tab ... /> component'\n          )\n\n        // make sure children is excluded otherwise our props will mutate too much\n        const { name, children, ...options } = element.props\n        if (tabOptions.has(name))\n          throw new Error(`Tab names must be unique, ${name} already exists`)\n\n        tabOptions.set(name, {\n          index,\n          name,\n          ...options,\n        })\n      })\n    }\n    return tabOptions\n  }, [children, tabType])\n  const optionEntries = Array.from(options.entries())\n  const optionKeys = Array.from(options.keys())\n  const memoizedOptions = useDeepCompareMemo(() => options, [optionEntries])\n  const memoizedTabNames = useDeepCompareMemo(() => optionKeys, [optionKeys])\n  return [memoizedOptions, memoizedTabNames]\n}\n\n/**\n * Hook exposing some useful variables.\n *\n * ```tsx\n * const { focusedTab, ...rest } = useTabsContext()\n * ```\n */\nexport function useTabsContext(): ContextType<TabName> {\n  const c = useContext(Context)\n  if (!c) throw new Error('useTabsContext must be inside a Tabs.Container')\n  return c\n}\n\n/**\n * Access the parent tab screen from any deep component.\n *\n * ```tsx\n * const tabName = useTabNameContext()\n * ```\n */\nexport function useTabNameContext(): TabName {\n  const c = useContext(TabNameContext)\n  if (!c) throw new Error('useTabNameContext must be inside a TabNameContext')\n  return c\n}\n\n/**\n * Hook to access some key styles that make the whole thing work.\n *\n * You can use this to get the progessViewOffset and pass to the refresh control of scroll view.\n */\nexport function useCollapsibleStyle(): CollapsibleStyle {\n  const { headerHeight, tabBarHeight, containerHeight } = useTabsContext()\n  const windowWidth = useWindowDimensions().width\n\n  return {\n    style: { width: windowWidth },\n    contentContainerStyle: {\n      minHeight: IS_IOS\n        ? (containerHeight || 0) - tabBarHeight\n        : (containerHeight || 0) + headerHeight,\n      paddingTop: IS_IOS ? 0 : headerHeight + tabBarHeight,\n    },\n    progressViewOffset: headerHeight + tabBarHeight,\n  }\n}\n\nexport function useUpdateScrollViewContentSize({ name }: { name: TabName }) {\n  const { tabNames, contentHeights } = useTabsContext()\n\n  const setContentHeights = useCallback(\n    (name: TabName, height: number) => {\n      const tabIndex = tabNames.value.indexOf(name)\n      contentHeights.value[tabIndex] = height\n      contentHeights.value = [...contentHeights.value]\n    },\n    [contentHeights, tabNames.value]\n  )\n\n  const scrollContentSizeChange = useCallback(\n    (_: number, h: number) => {\n      runOnUI(setContentHeights)(name, h)\n    },\n    [setContentHeights, name]\n  )\n\n  return scrollContentSizeChange\n}\n\n/**\n * Allows specifying multiple functions to be called in a sequence with the same parameters\n * Useful because we handle some events and need to pass them forward so that the caller can handle them as well\n * @param fns array of functions to call\n * @returns a function that once called will call all passed functions\n */\nexport function useChainCallback(...fns: (Function | undefined)[]) {\n  const callAll = useCallback(\n    (...args: unknown[]) => {\n      fns.forEach((fn) => {\n        if (typeof fn === 'function') {\n          fn(...args)\n        }\n      })\n    },\n    [fns]\n  )\n  return callAll\n}\n\nexport function useScroller<T extends RefComponent>() {\n  const { contentInset } = useTabsContext()\n\n  const scroller = useCallback(\n    (\n      ref: Ref<T> | undefined,\n      x: number,\n      y: number,\n      animated: boolean,\n      _debugKey: string\n    ) => {\n      'worklet'\n      if (!ref) return\n      // console.log(`${_debugKey}, y: ${y}, y adjusted: ${y - contentInset}`)\n      scrollToImpl(ref, x, y - contentInset, animated)\n    },\n    [contentInset]\n  )\n\n  return scroller\n}\n\nexport const useScrollHandlerY = (\n  name: TabName,\n  { enabled }: { enabled: boolean }\n) => {\n  const {\n    accDiffClamp,\n    focusedTab,\n    snapThreshold,\n    revealHeaderOnScroll,\n    refMap,\n    tabNames,\n    index,\n    headerHeight,\n    contentInset,\n    containerHeight,\n    scrollYCurrent,\n    scrollY,\n    isScrolling,\n    isGliding,\n    oldAccScrollY,\n    accScrollY,\n    offset,\n    headerScrollDistance,\n    isSnapping,\n    snappingTo,\n    contentHeights,\n  } = useTabsContext()\n\n  /**\n   * Helper value to track if user is dragging on iOS, because iOS calls\n   * onMomentumEnd only after a vigorous swipe. If the user has finished the\n   * drag, but the onMomentumEnd has never triggered, we need to manually\n   * call it to sync the scenes.\n   */\n  const afterDrag = useSharedValue(0)\n\n  const tabIndex = useMemo(() => tabNames.value.findIndex((n) => n === name), [\n    tabNames,\n    name,\n  ])\n\n  const scrollTo = useScroller()\n\n  const onMomentumEnd = () => {\n    'worklet'\n    if (!enabled) return\n\n    if (typeof snapThreshold === 'number') {\n      if (revealHeaderOnScroll) {\n        if (accDiffClamp.value > 0) {\n          if (\n            scrollYCurrent.value >\n            headerScrollDistance.value * snapThreshold\n          ) {\n            if (\n              accDiffClamp.value <=\n              headerScrollDistance.value * snapThreshold\n            ) {\n              // snap down\n              isSnapping.value = true\n              accDiffClamp.value = withTiming(0, undefined, () => {\n                isSnapping.value = false\n              })\n            } else if (accDiffClamp.value < headerScrollDistance.value) {\n              // snap up\n              isSnapping.value = true\n              accDiffClamp.value = withTiming(\n                headerScrollDistance.value,\n                undefined,\n                () => {\n                  isSnapping.value = false\n                }\n              )\n\n              if (scrollYCurrent.value < headerScrollDistance.value) {\n                scrollTo(\n                  refMap[name],\n                  0,\n                  headerScrollDistance.value,\n                  true,\n                  `[${name}] sticky snap up`\n                )\n              }\n            }\n          } else {\n            isSnapping.value = true\n            accDiffClamp.value = withTiming(0, undefined, () => {\n              isSnapping.value = false\n            })\n          }\n        }\n      } else {\n        if (\n          scrollYCurrent.value <=\n          headerScrollDistance.value * snapThreshold\n        ) {\n          // snap down\n          snappingTo.value = 0\n          scrollTo(refMap[name], 0, 0, true, `[${name}] snap down`)\n        } else if (scrollYCurrent.value <= headerScrollDistance.value) {\n          // snap up\n          snappingTo.value = headerScrollDistance.value\n          scrollTo(\n            refMap[name],\n            0,\n            headerScrollDistance.value,\n            true,\n            `[${name}] snap up`\n          )\n        }\n        isSnapping.value = false\n      }\n    }\n    isGliding.value = false\n  }\n\n  const contentHeight = useDerivedValue(() => {\n    const tabIndex = tabNames.value.indexOf(name)\n    return contentHeights.value[tabIndex] || Number.MAX_VALUE\n  }, [])\n\n  const scrollHandler = useAnimatedScrollHandler(\n    {\n      onScroll: (event) => {\n        if (!enabled) return\n\n        if (focusedTab.value === name) {\n          if (IS_IOS) {\n            let { y } = event.contentOffset\n            // normalize the value so it starts at 0\n            y = y + contentInset\n            const clampMax =\n              contentHeight.value - (containerHeight || 0) + contentInset\n            // make sure the y value is clamped to the scrollable size (clamps overscrolling)\n            scrollYCurrent.value = interpolate(\n              y,\n              [0, clampMax],\n              [0, clampMax],\n              Extrapolate.CLAMP\n            )\n          } else {\n            const { y } = event.contentOffset\n            scrollYCurrent.value = y\n          }\n\n          scrollY.value[index.value] = scrollYCurrent.value\n          oldAccScrollY.value = accScrollY.value\n          accScrollY.value = scrollY.value[index.value] + offset.value\n\n          if (!isSnapping.value && revealHeaderOnScroll) {\n            const delta = accScrollY.value - oldAccScrollY.value\n            const nextValue = accDiffClamp.value + delta\n            if (delta > 0) {\n              // scrolling down\n              accDiffClamp.value = Math.min(\n                headerScrollDistance.value,\n                nextValue\n              )\n            } else if (delta < 0) {\n              // scrolling up\n              accDiffClamp.value = Math.max(0, nextValue)\n            }\n          }\n\n          isScrolling.value = 1\n\n          // cancel the animation that is setting this back to 0 if we're still scrolling\n          cancelAnimation(isScrolling)\n\n          // set it back to 0 after a few frames without active scrolling\n          isScrolling.value = withDelay(\n            ONE_FRAME_MS * 3,\n            withTiming(0, { duration: 0 })\n          )\n        }\n      },\n      onBeginDrag: () => {\n        if (!enabled) return\n\n        // ensure the header stops snapping\n        cancelAnimation(accDiffClamp)\n\n        isSnapping.value = false\n        isScrolling.value = 0\n        isGliding.value = false\n\n        if (IS_IOS) cancelAnimation(afterDrag)\n      },\n      onEndDrag: () => {\n        if (!enabled) return\n\n        isGliding.value = true\n\n        if (IS_IOS) {\n          // we delay this by one frame so that onMomentumBegin may fire on iOS\n          afterDrag.value = withDelay(\n            ONE_FRAME_MS,\n            withTiming(0, { duration: 0 }, (isFinished) => {\n              // if the animation is finished, the onMomentumBegin has\n              // never started, so we need to manually trigger the onMomentumEnd\n              // to make sure we snap\n              if (isFinished) {\n                isGliding.value = false\n                onMomentumEnd()\n              }\n            })\n          )\n        }\n      },\n      onMomentumBegin: () => {\n        if (!enabled) return\n\n        if (IS_IOS) {\n          cancelAnimation(afterDrag)\n        }\n      },\n      onMomentumEnd,\n    },\n    [\n      refMap,\n      name,\n      revealHeaderOnScroll,\n      containerHeight,\n      contentInset,\n      snapThreshold,\n      enabled,\n      scrollTo,\n    ]\n  )\n\n  // sync unfocused scenes\n  useAnimatedReaction(\n    () => {\n      return (\n        !isSnapping.value && !isScrolling.value && !isGliding.value && enabled\n      )\n    },\n    (sync) => {\n      if (sync && focusedTab.value !== name) {\n        let nextPosition = null\n        const focusedScrollY = scrollY.value[index.value]\n        const tabScrollY = scrollY.value[tabIndex]\n        const areEqual = focusedScrollY === tabScrollY\n\n        if (!areEqual) {\n          const currIsOnTop = tabScrollY <= headerScrollDistance.value + 1\n          const focusedIsOnTop =\n            focusedScrollY <= headerScrollDistance.value + 1\n\n          if (revealHeaderOnScroll) {\n            const hasGap = accDiffClamp.value > tabScrollY\n            if (hasGap || currIsOnTop) {\n              nextPosition = accDiffClamp.value\n            }\n          } else if (typeof snapThreshold === 'number') {\n            if (focusedIsOnTop) {\n              nextPosition = snappingTo.value\n            } else if (currIsOnTop) {\n              nextPosition = headerHeight\n            }\n          } else if (currIsOnTop || focusedIsOnTop) {\n            nextPosition = Math.min(focusedScrollY, headerScrollDistance.value)\n          }\n        }\n\n        if (nextPosition !== null) {\n          scrollY.value[tabIndex] = nextPosition\n          scrollTo(refMap[name], 0, nextPosition, false, `[${name}] sync pane`)\n        }\n      }\n    },\n    [revealHeaderOnScroll, refMap, snapThreshold, tabIndex, enabled, scrollTo]\n  )\n\n  return scrollHandler\n}\n\ntype ForwardRefType<T> =\n  | ((instance: T | null) => void)\n  | MutableRefObject<T | null>\n  | null\n\n/**\n * Magic hook that creates a multicast ref. Useful so that we can both capture the ref, and forward it to callers.\n * Accepts a parameter for an outer ref that will also be updated to the same ref\n * @param outerRef the outer ref that needs to be updated\n * @returns an animated ref\n */\nexport function useSharedAnimatedRef<T extends RefComponent>(\n  outerRef: ForwardRefType<T>\n) {\n  const ref = useAnimatedRef<T>()\n\n  // this executes on every render\n  useEffect(() => {\n    if (!outerRef) {\n      return\n    }\n    if (typeof outerRef === 'function') {\n      outerRef(ref.current)\n    } else {\n      outerRef.current = ref.current\n    }\n  })\n\n  return ref\n}\n\nexport function useAfterMountEffect(effect: React.EffectCallback) {\n  const [didExecute, setDidExecute] = useState(false)\n  const result = useEffect(() => {\n    if (didExecute) return\n\n    const timeout = setTimeout(() => {\n      effect()\n      setDidExecute(true)\n    }, 0)\n    return () => {\n      clearTimeout(timeout)\n    }\n  }, [didExecute, effect])\n  return result\n}\n\nexport function useConvertAnimatedToValue<T>(\n  animatedValue: Animated.SharedValue<T>\n) {\n  const [value, setValue] = useState(animatedValue.value)\n\n  useAnimatedReaction(\n    () => {\n      return animatedValue.value\n    },\n    (animValue) => {\n      if (animValue !== value) {\n        runOnJS(setValue)(animValue)\n      }\n    },\n    [value]\n  )\n\n  return value\n}\n\ninterface HeaderMeasurements {\n  /**\n   * Animated value that represents the current Y translation of the header\n   */\n  top: Animated.SharedValue<number>\n  /**\n   * The height of the header\n   */\n  height: number\n}\n\nexport function useHeaderMeasurements(): HeaderMeasurements {\n  const { headerTranslateY, headerHeight } = useTabsContext()\n  return {\n    top: headerTranslateY,\n    height: headerHeight,\n  }\n}\n\n/**\n * Returns the currently focused tab name\n */\nexport function useFocusedTab() {\n  const { focusedTab } = useTabsContext()\n  const focusedTabValue = useConvertAnimatedToValue(focusedTab)\n  return focusedTabValue\n}\n\n/**\n * Returns an animated value representing the current tab index, as a floating point number\n */\nexport function useAnimatedTabIndex() {\n  const { indexDecimal } = useTabsContext()\n  return indexDecimal\n}\n"]},"metadata":{},"sourceType":"module"}